#include <QCoreApplication>
#include <QString>
#include <QThreadPool>
#include <QRunnable>
#include <QSqlQuery>
#include <QMutex>
#include <QHash>
#include <QFile>
#include <QVariant>
#include <QDebug>
#include <QSqlError>
#include <QTime>

const unsigned int EXPECTED_NUMBER = 50;
const int MAXIMUM_NUMBER = 100; // Should be 100

namespace
{
	bool execSqlQuery( QSqlQuery *query, const QString funcInfo, bool batchMode );

#define EXEC_SQL_QUERY( query, batchMode ) execSqlQuery( &query, Q_FUNC_INFO, batchMode );

	typedef unsigned int TaskId;

	QMutex save_data_mutex;
	const QStringList COLUMNS( QStringList() << "taskid" << "number" );

	class MyTread : public QRunnable // We need separated file for that. Keep class here as simple case
	{
		const QVariant m_taskId;
		const unsigned int m_numbersCount;
		QVariantList m_results;
		QVariantList m_taskIds; // Dumb collection. For query.execBatch();

	public:

		MyTread( const TaskId tId, const unsigned int numbersCount )
			: QRunnable()
			, m_taskId( tId )
			, m_numbersCount( numbersCount ) {	}

		void run()
		{
			setAutoDelete( true );
			for( unsigned int i = 0; i < m_numbersCount; ++i )
			{
				m_results << ( ( std::rand() + i ) /* Make random more random. Some implementations of rand() works not perfect */
							 % MAXIMUM_NUMBER );
				m_taskIds << m_taskId;
			}

			QSqlQuery query;
			query.prepare( QString( "INSERT INTO results ( %1 ) VALUES( ?,? )" ).arg( COLUMNS.join( " ," ) ) );
			query.addBindValue( m_taskIds );
			query.addBindValue( m_results );

			QMutexLocker locker( &save_data_mutex );
			qDebug() << "Save data from" << m_taskId.toString() << "thread";
			EXEC_SQL_QUERY( query, true );
		}
	};

	bool execSqlQuery( QSqlQuery *query, const QString funcInfo, bool batchMode )
	{
		if( !query )
		{
			Q_ASSERT( !"Null pointer! WTF??" );
			return false;
		}

		bool queryOk = false;

		if( batchMode )
			queryOk = query->execBatch();
		else
			queryOk = query->exec();

		if( !queryOk )
		{
			qDebug() << "------- SQL query completed with errors-------";
			qDebug() << funcInfo;
			qDebug() << query->lastQuery();
			qDebug() << query->lastError();
			qDebug() << "----------------------------------------------";
		}

		return queryOk;
	}

	bool createTable( const QString& tableName, const QStringList& columns )
	{
		QSqlQuery query;
		query.prepare(
					QString( "CREATE TABLE %1 "
				  "( id INTEGER PRIMARY KEY AUTOINCREMENT, %2 )" )
					   .arg( tableName )
					   .arg( columns.join( " ," ) )
					);
		bool result = EXEC_SQL_QUERY( query, false );

		return result;
	}
}

int main(int argc, char *argv[])
{
	QCoreApplication a(argc, argv);
	const QStringList arguments( a.arguments() );
	QString errorString;

	if( arguments.size() == 3 ) // Programm name + 2 numbers expected
	{
		bool ok1 = true, ok2 = true;
		const unsigned int n = arguments.at( 1 ).toUInt( &ok1 );
		const unsigned int t = arguments.at( 2 ).toUInt( &ok2 );

		if( ok1 && ok2 )
		{
			const QString fileName( "./db.sqlite" );
			QFile oldDb( fileName );
			oldDb.remove();
			oldDb.close(); // For some case

			QSqlDatabase database = QSqlDatabase::addDatabase( "QSQLITE" );
			database.setDatabaseName( fileName );

			if( database.open()
					&& createTable( "results", COLUMNS ) ) // Main logic
			{	
				srand( qHash( QTime::currentTime() ) );
				TaskId taskId = 0; // Different variable for case when taskid type will change
				QThreadPool generatorsPool;
				qDebug() << "Starting" << t << "threads" << "for generate" << n << "numbers per every thread";

				for( unsigned int i = 0; i < t; ++i )
				{
					MyTread* const thread = new MyTread( taskId++, n );
					generatorsPool.start( thread );
				}

				generatorsPool.waitForDone();

				// Suppose I need to make complicated SQL query instead simple count wanted ('50') values in each thread
				// So, let's see my skills in SQL ... :)

				QSqlQuery query;
				query.prepare( "SELECT taskid, count(1) FROM results WHERE number = :number GROUP BY taskid ORDER BY taskid" );
				query.bindValue( ":number", EXPECTED_NUMBER );
				EXEC_SQL_QUERY( query, false );
				qInfo() << "\nSearch number" << QString::number( EXPECTED_NUMBER ) << "in results DB";

				while( query.next() )
				{
					qInfo() << "Founded" << query.value( 1 ).toUInt() << "numbers generated by" << query.value( 0 ).toString() << "thread";
				}

				if( !query.first() ) // Just replacing for "query.size() > 0" checking. "query.size()" not works in any case
				{
					qInfo() << "Sorry! Expected number not founded ";
				}
			}
			else
				errorString = "Can't work with DB file. Or errors in SQL driver";
		}
		else
			errorString = "Seems not numbers in your input";
	}
	else if( arguments.size() == 1 )
	{
		errorString = "Please use ./IvanovTestTask <numbers amount> <threads amount>";
	}
	else
		errorString = "Please define only 2 numeric arguments";

	if( !errorString.isEmpty() )
		qInfo() << errorString;

	::exit( 0 );

	return a.exec();
}
